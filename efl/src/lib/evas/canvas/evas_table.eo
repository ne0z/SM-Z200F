class Evas.Table (Evas.Smart_Clipped)
{
   legacy_prefix: evas_object_table;
   eo_prefix: evas_obj_table;
   properties {
      homogeneous {
         set {
            /*@
            @brief Set how this table should layout children.

            @if MOBILE @since_tizen 2.3
            @elseif WEARABLE @since_tizen 2.3.1
            @endif

            @ingroup Evas_Object_Table

            @todo consider aspect hint and respect it.

            @par EVAS_OBJECT_TABLE_HOMOGENEOUS_NONE
            @remark If table does not use homogeneous mode then columns and rows will
            be calculated based on hints of individual cells. This operation
            mode is more flexible, but more complex and heavy to calculate as
            well. @b Weight properties are handled as a boolean expand. Negative
            alignment will be considered as 0.5. This is the default.

            @todo @c EVAS_OBJECT_TABLE_HOMOGENEOUS_NONE should balance weight.

            @par EVAS_OBJECT_TABLE_HOMOGENEOUS_TABLE
            @remark When homogeneous is relative to table the own table size is divided
            equally among children, filling the whole table area. That is, if
            table has @c WIDTH and @c COLUMNS, each cell will get <tt>WIDTH /
            COLUMNS</tt> pixels. If children have minimum size that is larger
            than this amount (including padding), then it will overflow and be
            aligned respecting the alignment hint, possible overlapping sibling
            cells. @b Weight hint is used as a boolean, if greater than zero it
            will make the child expand in that axis, taking as much space as
            possible (bounded to maximum size hint). Negative alignment will be
            considered as 0.5.

            @par EVAS_OBJECT_TABLE_HOMOGENEOUS_ITEM
            @remark When homogeneous is relative to item it means the greatest minimum
            cell size will be used. That is, if no element is set to expand,
            the table will have its contents to a minimum size, the bounding
            box of all these children will be aligned relatively to the table
            object using evas_object_table_align_get(). If the table area is
            too small to hold this minimum bounding box, then the objects will
            keep their size and the bounding box will overflow the box area,
            still respecting the alignment. @b Weight hint is used as a
            boolean, if greater than zero it will make that cell expand in that
            axis, toggling the <b>expand mode</b>, which makes the table behave
            much like @b EVAS_OBJECT_TABLE_HOMOGENEOUS_TABLE, except that the
            bounding box will overflow and items will not overlap siblings. If
            no minimum size is provided at all then the table will fallback to
            expand mode as well. */
         }
         get {
            /*@
            @brief Get the current layout homogeneous mode.

            @if MOBILE @since_tizen 2.3
            @elseif WEARABLE @since_tizen 2.3.1
            @endif

            @ingroup Evas_Object_Table

            @see evas_object_table_homogeneous_set() */
         }
         values {
            Evas_Object_Table_Homogeneous_Mode homogeneous;
         }
      }
      align {
         set {
            /*@
            @brief Set the alignment of the whole bounding box of contents.

            @if MOBILE @since_tizen 2.3
            @elseif WEARABLE @since_tizen 2.3.1
            @endif

            @ingroup Evas_Object_Table

            */
         }
         get {
            /*@
            @brief Get alignment of the whole bounding box of contents.

            @if MOBILE @since_tizen 2.3
            @elseif WEARABLE @since_tizen 2.3.1
            @endif

            @ingroup Evas_Object_Table

            */
         }
         values {
            double horizontal;
            double vertical;
         }
      }
      padding {
         set {
            /*@
            @brief Set padding between cells.

            @if MOBILE @since_tizen 2.3
            @elseif WEARABLE @since_tizen 2.3.1
            @endif

            @ingroup Evas_Object_Table

            */
         }
         get {
            /*@
            @brief Get padding between cells.

            @if MOBILE @since_tizen 2.3
            @elseif WEARABLE @since_tizen 2.3.1
            @endif

            @ingroup Evas_Object_Table

            */
         }
         values {
            Evas_Coord horizontal;
            Evas_Coord vertical;
         }
      }
      mirrored {
         set {
            /*@
            @brief Sets the mirrored mode of the table. In mirrored mode the table items go
            from right to left instead of left to right. That is, 1,1 is top right, not
            top left.

            @if MOBILE @since_tizen 2.3
            @elseif WEARABLE @since_tizen 2.3.1
            @endif

            @ingroup Evas_Object_Table

            @since 1.1 */
         }
         get {
            /*@
            @brief Gets the mirrored mode of the table.

            @if MOBILE @since_tizen 2.3
            @elseif WEARABLE @since_tizen 2.3.1
            @endif

            @ingroup Evas_Object_Table

            @return @c EINA_TRUE if it's a mirrored table, @c EINA_FALSE otherwise.
            @since 1.1
            @see evas_object_table_mirrored_set() */
         }
         values {
            bool mirrored; /*@ the mirrored mode to set */
         }
      }
      col_row_size {
         get {
            /*@
            @brief Get the number of columns and rows this table takes.

            @if MOBILE @since_tizen 2.3
            @elseif WEARABLE @since_tizen 2.3.1
            @endif

            @ingroup Evas_Object_Table

            @remark columns and rows are virtual entities, one can specify a table
            with a single object that takes 4 columns and 5 rows. The only
            difference for a single cell table is that paddings will be
            accounted proportionally. */
         }
         values {
            int cols;
            int rows;
         }
      }
      children {
         get {
            /*@
            @brief Get the list of children for the table.

            @if MOBILE @since_tizen 2.3
            @elseif WEARABLE @since_tizen 2.3.1
            @endif

            @ingroup Evas_Object_Table

            @remark This is a duplicate of the list kept by the table internally.
            It's up to the user to destroy it when it no longer needs it.
            It's possible to remove objects from the table when walking this
            list, but these removals won't be reflected on it. */
            return: free(own(list<Evas.Object *> *), eina_list_free) @warn_unused;
         }
      }
      child {
         get {
            /*@
            @brief Get the child of the table at the given coordinates

            @if MOBILE @since_tizen 2.3
            @elseif WEARABLE @since_tizen 2.3.1
            @endif

            @ingroup Evas_Object_Table

            @remark This does not take into account col/row spanning*/
         }
         keys {
            ushort col;
            ushort row;
         }
         values {
            Evas_Object *child;
         }
      }
   }
   methods {
      clear {
         /*@
         @brief Faster way to remove all child objects from a table object.

         @if MOBILE @since_tizen 2.3
         @elseif WEARABLE @since_tizen 2.3.1
         @endif

         @ingroup Evas_Object_Table

         */

         params {
            @in bool clear; /*@ if true, it will delete just removed children. */
         }
      }
      accessor_new @const {
         /*@
         @brief Get an accessor to get random access to the list of children for the table.

         @if MOBILE @since_tizen 2.3
         @elseif WEARABLE @since_tizen 2.3.1
         @endif

         @ingroup Evas_Object_Table

         @note Do not remove or delete objects while walking the list. */
         return: free(own(accessor<Evas.Object *> *), eina_accessor_free)
            @warn_unused;
      }
      iterator_new @const {
         /*@
         @brief Get an iterator to walk the list of children for the table.

         @if MOBILE @since_tizen 2.3
         @elseif WEARABLE @since_tizen 2.3.1
         @endif

         @ingroup Evas_Object_Table

         @remark Do not remove or delete objects while walking the list. */
         return: free(own(iterator<Evas.Object *> *), eina_iterator_free)
            @warn_unused;
      }
      add_to {
         /*@
         @brief Create a table that is child of a given element @a parent.

         @if MOBILE @since_tizen 2.3
         @elseif WEARABLE @since_tizen 2.3.1
         @endif

         @ingroup Evas_Object_Table

         @see evas_object_table_add() */

         return: Evas_Object * @warn_unused;
      }
      pack_get @const {
         /*@
         @brief Get packing location of a child of table

         @if MOBILE @since_tizen 2.3
         @elseif WEARABLE @since_tizen 2.3.1
         @endif

         @ingroup Evas_Object_Table

         @return 1 on success, 0 on failure.
         @since 1.1 */
         return: bool;
         params {
            @in Evas_Object *child; /*@ The child object to add. */
            @out ushort col; /*@ pointer to store relative-horizontal position to place child. */
            @out ushort row; /*@ pointer to store relative-vertical position to place child. */
            @out ushort colspan; /*@ pointer to store how many relative-horizontal position to use for this child. */
            @out ushort rowspan; /*@ pointer to store how many relative-vertical position to use for this child. */
         }
      }
      pack {
         /*@
         @brief Add a new child to a table object or set its current packing.

         @if MOBILE @since_tizen 2.3
         @elseif WEARABLE @since_tizen 2.3.1
         @endif

         @ingroup Evas_Object_Table

         @remark Note that columns and rows only guarantee 16bit unsigned values at best.
         That means that col + colspan AND row + rowspan must fit inside 16bit
         unsigned values cleanly. You will be warned once values exceed 15bit
         storage, and attempting to use values not able to fit in 16bits will
         result in failure.

         @return 1 on success, 0 on failure. */

         return: bool;
         params {
            @in Evas_Object *child @nonull; /*@ The child object to add. */
            @in ushort col; /*@ relative-horizontal position to place child. */
            @in ushort row; /*@ relative-vertical position to place child. */
            @in ushort colspan; /*@ how many relative-horizontal position to use for this child. */
            @in ushort rowspan; /*@ how many relative-vertical position to use for this child. */
         }
      }
      unpack {
         /*@
         @brief Remove child from table.

         @if MOBILE @since_tizen 2.3
         @elseif WEARABLE @since_tizen 2.3.1
         @endif

         @ingroup Evas_Object_Table

         @remark removing a child will immediately call a walk over children in order
         to recalculate numbers of columns and rows. If you plan to remove
         all children, use evas_object_table_clear() instead.

         @return 1 on success, 0 on failure. */

         return: bool;
         params {
            @in Evas_Object *child @nonull;
         }
      }
   }
   implements {
      class.constructor; 
      Eo.Base.constructor;
      Evas.Object_Smart.add;
      Evas.Object_Smart.del;
      Evas.Object_Smart.calculate;
      Evas.Object_Smart.resize;
   }
}
