#   Copyright (C) 2011 Samsung Electronics
#
#   This library is free software; you can redistribute it and/or
#   modify it under the terms of the GNU Lesser General Public
#   License as published by the Free Software Foundation; either
#   version 2.1 of the License, or (at your option) any later version.
#
#   This library is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   Lesser General Public License for more details.
#
#   You should have received a copy of the GNU Lesser General Public
#   License along with this library; if not, write to the Free Software
#   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

package CodeGeneratorEWK;

# Global Variables
my $module = "";
my $outputDir = "";

my @headerContentHeader = ();
my @headerContent = ();
my %headerForwardDeclarations = ();

my @privateHeaderContentHeader = ();
my @privateHeaderContent = ();

my @implContentHeader = ();
my @implContent = ();
my %implIncludes = ();

# Constants
my $exceptionInit = "WebCore::ExceptionCode ec = 0;";
my $exceptionRaiseOnError = "// WebKitDOM_RaiseError(static_cast<WebKitDOM_ExceptionCode>(ec)); // TODO: Exceptions";

# Default License Templates
my $headerLicenseTemplate = << "EOF";
/*
    Copyright (C) 2011 Samsung Electronics

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/
EOF

my $implementationLicenseTemplate = << "EOF";
/*
    This file is part of the WebKit open source project.
    This file has been generated by generate-bindings.pl. DO NOT MODIFY!

    Copyright (C) 2011 Samsung Electronics

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/
EOF

# Default constructor
sub new
{
    my $object = shift;
    my $reference = { };

    $codeGenerator = shift;
    $outputDir = shift;
    shift; # $outputHeadersDir
    shift; # $useLayerOnTop
    shift; # $preprocessor
    shift; # $writeDependencies

    bless($reference, $object);
    return $reference;
}

sub finish
{
    my $object = shift;
}

sub decamelize
{
        my $s = shift;
        $s =~ s{([^a-zA-Z]?)([A-Z]*)([A-Z])([a-z]?)}{
                my $fc = pos($s)==0;
                my ($p0,$p1,$p2,$p3) = ($1,lc$2,lc$3,$4);
                my $t = $p0 || $fc ? $p0 : '_';
                $t .= $p3 ? $p1 ? "${p1}_$p2$p3" : "$p2$p3" : "$p1$p2";
                $t;
        }ge;
        return $s;
}

sub FixUpDecamelizedName {
    my $classname = shift;

    # FIXME: try to merge this somehow with the fixes in ClassNameToGobjectType
    $classname =~ s/x_path/xpath/;
    $classname =~ s/web_kit/webkit/;
    $classname =~ s/htmli_frame/html_iframe/;

    return $classname;
}


# Params: 'domClass' struct
sub GenerateInterface
{
    my $object = shift;
    my $dataNode = shift;
    my $defines = shift;

    my $name = $dataNode->name;
    my $className = GetClassName($name);
    my $parentClassName = "WebKitDOM_" . GetParentImplClassName($dataNode);

    # Start actual generation.
    $object->GenerateHeader($dataNode);
    $object->GeneratePrivateHeader($dataNode);
    $object->GenerateImplementation($dataNode);

    # Write changes.
    $object->WriteData("WebKitDOM_" . $name);
}

# Params: 'idlDocument' struct
sub GenerateModule
{
    my $object = shift;
    my $dataNode = shift;

    $module = $dataNode->module;
}

sub GetClassName
{
    my $name = $codeGenerator->StripModule(shift);

    # special cases
    return "WebKitDOM_String" if $codeGenerator->IsStringType($name) or $name eq "SerializedScriptValue";
    return "WebKitDOM_Object" if $name eq "DOMObject";
    return "Eina_Bool" if $name eq "boolean";
    return $name if $codeGenerator->IsPrimitiveType($name);
    return "WebKitDOM_CustomVoidCallback" if $name eq "VoidCallback";

    return "WebKitDOM_$name";
}

sub GetImplClassName
{
    return $codeGenerator->StripModule(shift);
}

sub GetParentImplClassName
{
    my $dataNode = shift;

    if (@{$dataNode->parents} eq 0) {
        return "EventTarget" if $dataNode->extendedAttributes->{"EventTarget"};
        return "Object";
    }

    return $codeGenerator->StripModule($dataNode->parents(0));
}

sub GetParent
{
    my $dataNode = shift;
    my $numParents = @{$dataNode->parents};

    my $parent = "";
    if ($numParents eq 0) {
        $parent = "WebKitDOM_Object";
        $parent = "WebKitDOM_EventTarget" if $dataNode->extendedAttributes->{"EventTarget"};
    } elsif ($numParents eq 1) {
        my $parentName = $codeGenerator->StripModule($dataNode->parents(0));
        $parent = "WebKitDOM_" . $parentName;
    } else {
        my @parents = @{$dataNode->parents};
        my $firstParent = $codeGenerator->StripModule(shift(@parents));
        $parent = "WebKitDOM_" . $firstParent;
    }

    return $parent;
}

sub ShouldSkipTypeInImplementation
{
    my $typeInfo = shift;

    return 0 if $typeInfo->signature->name =~ /item/; #for HTMLCollection - need to check class!!
    return 0 if $typeInfo->signature->name =~ /namedItem/; #for HTMLCollection - need to check class!!

    return 1 if $typeInfo->signature->extendedAttributes->{"Custom"}
             and !$typeInfo->signature->extendedAttributes->{"NoCPPCustom"};

    return 1 if $typeInfo->signature->extendedAttributes->{"CustomArgumentHandling"}
             or $typeInfo->signature->extendedAttributes->{"CustomGetter"}
             or $typeInfo->signature->extendedAttributes->{"NeedsUserGestureCheck"}
             or $typeInfo->signature->extendedAttributes->{"CPPCustom"};

    # FIXME: We don't generate bindings for SVG related interfaces yet
    return 1 if $typeInfo->signature->name =~ /getSVGDocument/;

    return 1 if $typeInfo->signature->name =~ /getCSSCanvasContext/;

    return 1 if $typeInfo->signature->name =~ /location/;

    return 1 if $typeInfo->signature->name =~ /Constructor/;

    return 1 if $typeInfo->signature->name =~ /setTimeout/;
    return 1 if $typeInfo->signature->name =~ /setInterval/;

    if ($typeInfo->signature->type eq "Crypto") {
        return 1;
    }

    return 0;
}

sub ShouldSkipTypeInHeader
{
    my $typeInfo = shift;

    # FIXME: We currently ignore any attribute/function needing custom code
    return 1 if $typeInfo->signature->extendedAttributes->{"CustomArgumentHandling"}
             or $typeInfo->signature->extendedAttributes->{"CustomGetter"};

    # FIXME: We don't generate bindings for SVG related interfaces yet
    return 1 if $typeInfo->signature->name =~ /getSVGDocument/;

    return 1 if $typeInfo->signature->name =~ /getCSSCanvasContext/;

    return 1 if $typeInfo->signature->name =~ /location/;

    return 1 if $typeInfo->signature->name =~ /Constructor/;

    return 1 if $typeInfo->signature->name =~ /setTimeout/; # problems with TimeoutHanler
    return 1 if $typeInfo->signature->name =~ /setInterval/;

    return 1 if $typeInfo->signature->name =~ /pushState/; # problems with "any" and "optional"
    return 1 if $typeInfo->signature->name =~ /replaceState/;

    if ($typeInfo->signature->type eq "Crypto") {
        return 1;
    }

    return 0;
}

sub GetCType
{
    my $type = shift;
    my $useConstReference = shift;
    my $name = GetClassName($type);

    return "int" if $type eq "long";
    return "unsigned" if $name eq "unsigned long";
    return "unsigned short" if $type eq "CompareHow";
    return "double" if $name eq "Date";
    return "unsigned" if $type eq "DOMTimeStamp";

#    return "long" if $type eq "TimeoutHandler"; # why this is generated? functions using this type are custom and shouldnt be generated.

    return $name if $codeGenerator->IsPrimitiveType($type) or $type eq "DOMTimeStamp";
    return "$name*" if $useConstReference;
    return "$name";
}

sub ConversionNeeded
{
    my $type = $codeGenerator->StripModule(shift);
    return !$codeGenerator->IsNonPointerType($type) && !$codeGenerator->IsStringType($type);
}

sub GetCTypeGetter
{
    my $argName = shift;
    my $type = $codeGenerator->StripModule(shift);

    return "_to_webcore_string_value($argName)" if $codeGenerator->IsStringType($type);
    return $argName if $codeGenerator->IsPrimitiveType($type);
    return "static_cast<WebCore::Range::CompareHow>($argName)" if $type eq "CompareHow";
    return "WebCore::SerializedScriptValue::create(WTF::String($argName))" if $type eq "SerializedScriptValue";
    return "_to_webcore_". lc($type) . "($argName)";
}

sub AddForwardDeclarationsForType
{
    my $type = $codeGenerator->StripModule(shift);
    my $public = shift;

    return if $codeGenerator->IsNonPointerType($type) or $codeGenerator->IsStringType($type);

    my $class = GetClassName($type);
    $headerForwardDeclarations{$class} = 1 if $public;
}

sub AddIncludesForType
{
    my $type = $codeGenerator->StripModule(shift);

    return if $codeGenerator->IsNonPointerType($type);
    return if $type =~ /Constructor/;

    if ($codeGenerator->IsStringType($type)) {
        $implIncludes{"wtf/text/AtomicString.h"} = 1;
        $implIncludes{"KURL.h"} = 1;
        $implIncludes{"WebKitDOM_String.h"} = 1;
        $implIncludes{"WebKitDOM_String_Private.h"} = 1;
        return;
    }

    if ($type eq "DOMObject") {
        return;
    }

    if ($type eq "SerializedScriptValue") {
        return;
    }

    if ($type eq "VoidCallback") {
        return;
    }

    $implIncludes{"Node.h"} = 1 if $type eq "NodeList";
    $implIncludes{"CSSMutableStyleDeclaration.h"} = 1 if $type eq "CSSStyleDeclaration";

    # Default, include the same named file (the implementation) and the same name prefixed with "WebKitDOM_".
    $implIncludes{"$type.h"} = 1 unless $type eq "DOMObject";
    $implIncludes{"WebKitDOM_$type.h"} = 1;
    $implIncludes{"WebKitDOM_${type}_Private.h"} = 1;
}

sub GenerateConditionalStringFromAttributeValue
{
    my $conditional = shift;
    my $condition = "";
    if ($conditional =~ /&/) {
        $condition =  join(") && ENABLE(", split(/&/, $conditional));
    } elsif ($conditional =~ /\|/) {
        $condition = join(") || ENABLE(", split(/\|/, $conditional));
    } else {
        $condition = $conditional;
    }

    return "(defined ENABLE_$condition  && ENABLE_$condition)";
}

sub GenerateConditionalString
{
    my $node = shift;
    my $conditional = $node->extendedAttributes->{"Conditional"};
    if ($conditional) {
        return GenerateConditionalStringFromAttributeValue($conditional);
    } else {
        return "";
    }
}

sub GeneratePrivateHeader
{
    my $object = shift;
    my $dataNode = shift;

    my $interfaceName = $dataNode->name;
    my $className = GetClassName($interfaceName);

    # - Add default header template
    @privateHeaderContentHeader = split("\r", $headerLicenseTemplate);

    my $conditionalString = GenerateConditionalString($dataNode);
    push(@privateHeaderContentHeader, "#if ${conditionalString}\n\n") if $conditionalString;

    push(@privateHeaderContentHeader, "\n#ifndef $className" . "_Private_h");
    push(@privateHeaderContentHeader, "\n#define $className" . "_Private_h\n");

    push(@privateHeaderContentHeader, "\n#include \"$interfaceName.h\"\n" );

    push(@privateHeaderContentHeader, "\n#ifdef __cplusplus");
    push(@privateHeaderContentHeader, "\nextern \"C\" {");
    push(@privateHeaderContentHeader, "\n#endif\n");

    push(@privateHeaderContent, "\nWebCore::$interfaceName* _to_webcore_" . lc($interfaceName) . "(const $className* kitObj);");
    push(@privateHeaderContent, "\n$className* _to_webkit_" . lc($interfaceName) . "(WebCore::$interfaceName* coreObj, $className* ret);");

    push(@privateHeaderContent, "\n");

    push(@privateHeaderContent, "\n");
    push(@privateHeaderContent, "\n#ifdef __cplusplus");
    push(@privateHeaderContent, "\n}");
    push(@privateHeaderContent, "\n#endif\n");

    push(@privateHeaderContent, "\n#endif\n");

    push(@privateHeaderContent, "\n#endif // ${conditionalString}\n\n") if $conditionalString;
}

sub IsWraperType
{
    my $typeName = shift;

    return $typeName =~ m/WebKitDOM_/;
}

sub WraperType2CoreType
{
    my $typeName = shift;

    if ($typeName =~ m/WebKitDOM_/) {
        return substr( $typeName,length( "WebKitDOM_") );
    }

    return $typeName;
}

sub GenerateHeader
{
    my $object = shift;
    my $dataNode = shift;

    my $interfaceName = $dataNode->name;
    my $className = GetClassName($interfaceName);
    my $implClassName = GetImplClassName($interfaceName);
    my $implClassNameWithNamespace = "WebCore::" . $implClassName;

    my $parentName = "";
    $parentName = GetParent($dataNode);

    my $numConstants = @{$dataNode->constants};
    my $numAttributes = @{$dataNode->attributes};
    my $numFunctions = @{$dataNode->functions};

    # - Add default header template
    @headerContentHeader = split("\r", $headerLicenseTemplate);

    my $conditionalString = GenerateConditionalString($dataNode);
    push(@headerContentHeader, "#if ${conditionalString}\n\n") if $conditionalString;

    push(@headerContentHeader, "\n#ifndef $className" . "_h");
    push(@headerContentHeader, "\n#define $className" . "_h\n\n");

    # - INCLUDES -
    my %headerIncludes = ();
    $headerIncludes{"WebKitDOM_Defines.h"} = 1;
    $headerIncludes{"$parentName.h"} = 1;
    foreach my $include (sort keys(%headerIncludes)) {
        push(@headerContentHeader, "#include <$include>\n");
    }

    push(@headerContentHeader, "\n#ifdef __cplusplus");
    push(@headerContentHeader, "\nextern \"C\" {");
    push(@headerContentHeader, "\n#endif\n");

    push(@headerContent, "#define WEBKITDOM_" . uc($implClassName) . "_INIT(objPtr) \\\n");
    push(@headerContent, "    (((WebKitDOM_Object*)(objPtr))->p_coreObject) = 0; \\\n");
    push(@headerContent, "    (((WebKitDOM_Object*)(objPtr))->deinit) = ewk_webkitdom_" . lc($implClassName) . "_deinit\n");

    push(@headerContent, "\nstruct _$className {");
    push(@headerContent, "\n    $parentName parent_object;") if $parentName;
    push(@headerContent, "\n};\n\n");

    my $decamelize = FixUpDecamelizedName(decamelize($interfaceName));

    # - Add constants.
    if ($numConstants > 0) {
        my @headerConstants = ();

        foreach my $constant (@{$dataNode->constants}) {
            my $constantName = $constant->name;
            my $constantValue = $constant->value;

            push(@headerConstants, "#define    WEBKITDOM_" . $constantName . "        " . $constantValue);
        }

        my $combinedConstants = join("\n", @headerConstants);

        push(@headerContent, $combinedConstants);
        push(@headerContent, "\n\n");
    }

    my @headerAttributes = ();

    # - Add attribute getters/setters.
    if ($numAttributes > 0) {
        foreach my $attribute (@{$dataNode->attributes}) {
            next if ShouldSkipTypeInHeader($attribute);

            my $attributeConditionalString = GenerateConditionalString($attribute->signature);
            my $attributeName = $attribute->signature->name;
            my $attributeType = GetCType($attribute->signature->type, 0);
            my $attributeIsReadonly = ($attribute->type =~ /^readonly/);
            my $property = "";

            $property .= "/* #if ${attributeConditionalString}\n" if $attributeConditionalString;
            $property .= "EAPI " . GenerateGetterPrototype($attribute, $interfaceName);

            my $availabilityMacro = "";
            my $declarationSuffix = ";\n";

            AddForwardDeclarationsForType($attribute->signature->type, 1);

            $attributeType = GetCType($attribute->signature->type, 1);
            my $setterName = "ewk_webkitdom_" . lc($implClassName) . "_set_" . decamelize($attributeName) . "($className* self";

            $property .= $declarationSuffix;
            push(@headerAttributes, $property);
            if (!$attributeIsReadonly and !$attribute->signature->extendedAttributes->{"Replaceable"}) {
                $property = "EAPI void $setterName, $attributeType)";
                $property .= $declarationSuffix;
                push(@headerAttributes, $property);
            }

            push(@headerAttributes, "#endif */\n") if $attributeConditionalString;

            push(@headerAttributes, "\n");
        }
        push(@headerContent, @headerAttributes) if @headerAttributes > 0;
    }

    my @headerFunctions = ();
    my @deprecatedHeaderFunctions = ();
    my @interfaceFunctions = ();

    # - Add functions.
    if ($numFunctions > 0) {
        foreach my $function (@{$dataNode->functions}) {
            next if ShouldSkipTypeInHeader($function);
            my $functionSigName = $function->signature->name;
            my $functionName = "ewk_webkitdom_" . lc($implClassName) . "_" . decamelize($functionSigName);

            my $returnType = GetCType($function->signature->type, 0);
            my $numberOfParameters = @{$function->parameters};
            my %typesToForwardDeclare = ($function->signature->type => 1);

            my $parameterIndex = 0;
            my $functionSig = "EAPI ";
            if (IsWraperType($returnType)) {
                $functionSig .= "void $functionName($className* self";
            } else {
                $functionSig .= "$returnType $functionName($className* self";
            }

            my $methodName = $functionName;
            foreach my $param (@{$function->parameters}) {
                my $paramName = $param->name;
                my $paramType = GetCType($param->type, 1);
                $typesToForwardDeclare{$param->type} = 1;
                
                $functionSig .= ", $paramType $paramName";
                $parameterIndex++;
            }

            if (IsWraperType($returnType)) {
                $functionSig .= ", $returnType* ret";
            }

            $functionSig .= ")";
            my $functionDeclaration = $functionSig;
            $functionDeclaration .= ";\n";

            foreach my $type (keys %typesToForwardDeclare) {
                # add any forward declarations to the public header if a deprecated version will be generated
                AddForwardDeclarationsForType($type, 1);
            }

            push(@headerFunctions, $functionDeclaration);
        }

        if (@headerFunctions > 0) {
            push(@headerContent, "\n") if @headerAttributes > 0;
            push(@headerContent, @headerFunctions);
        }
    }

    push(@headerContent, "\nEAPI void ewk_webkitdom_" . lc($implClassName) . "_deinit(const WebKitDOM_Object*);");
    push(@headerContent, "\nEAPI void _copy_webkit_" . lc($implClassName) . "($className* kitObjSrc, $className* ret);");

    push(@headerContent, "\n");
    push(@headerContent, "\n#ifdef __cplusplus");
    push(@headerContent, "\n}");
    push(@headerContent, "\n#endif\n");

    push(@headerContent, "\n#endif\n");
    push(@headerContent, "\n#endif // ${conditionalString}\n\n") if $conditionalString;
    push(@headerContent, "\n");
}

sub AddEarlyReturnStatement
{
    my $returnType = shift;

    if (!defined($returnType) or $returnType eq "void") {
        $returnType = "";
    } elsif ($codeGenerator->IsPrimitiveType($returnType)) {
        $returnType = " 0";
    } elsif ($returnType eq "Eina_Bool") {
        $returnType = " EINA_FALSE";
    } elsif ( !IsWraperType( $returnType ) && substr($returnType,-1,1) eq "*") {
        $returnType = " 0";
    } elsif ( IsWraperType( $returnType ) ) {
        $returnType = "";
    } else {
        $returnType = " $returnType()";
    }

    # TODO: We could set exceptions here, if we want that
    my $statement = "    if (!self)\n";
    $statement .=   "        return$returnType;\n\n";
    return $statement;
}

sub AddReturnStatement
{
    my $typeInfo = shift;
    my $returnValue = shift;

    return "    return $returnValue;\n";
}

sub GenerateGetterPrototype
{
    my $attribute = shift;
    my $interfaceName = shift;

    my $className = GetClassName($interfaceName);
    my $implClassName = GetImplClassName($interfaceName);

    my $attributeName = $attribute->signature->name;
    my $attributeType = GetCType($attribute->signature->type, 0);
    my $attributeIsReadonly = ($attribute->type =~ /^readonly/);

    my $getterSig = "";
    if (IsWraperType($attributeType)) {
        $getterSig .= "void ewk_webkitdom_" . lc($implClassName) . "_get_" . decamelize($attributeName) . "($className* self, $attributeType* ret)";
    } else {
        $getterSig .= $attributeType . " ewk_webkitdom_" . lc($implClassName) . "_get_" . decamelize($attributeName) . "($className* self)";
    }

    return $getterSig;
}

sub GenerateImplementation
{
    my $object = shift;
    my $dataNode = shift;

    my @ancestorInterfaceNames = ();

    if (@{$dataNode->parents} > 1) {
        $codeGenerator->AddMethodsConstantsAndAttributesFromParentClasses($dataNode, \@ancestorInterfaceNames);
    }

    my $interfaceName = $dataNode->name;
    my $className = GetClassName($interfaceName);
    my $implClassName = GetImplClassName($interfaceName);
    my $parentImplClassName = GetParentImplClassName($dataNode);
    my $implClassNameWithNamespace = "WebCore::" . $implClassName;
    my $baseClass = "WebKitDOM_$parentImplClassName";
    my $conditional = $dataNode->extendedAttributes->{"Conditional"};

    my $numAttributes = @{$dataNode->attributes};
    my $numFunctions = @{$dataNode->functions};

    # - Add default header template.
    @implContentHeader = split("\r", $implementationLicenseTemplate);

    # - INCLUDES -
    push(@implContentHeader, "\n#include \"config.h\"\n");
    push(@implContentHeader, "#include \"$className.h\"\n");
    push(@implContentHeader, "#include \"${className}_Private.h\"\n\n");

    $implIncludes{"$implClassName.h"} = 1;
    @implContent = ();

    push(@implContent, "#include <wtf/text/CString.h>\n");
    push(@implContent, "#include <wtf/GetPtr.h>\n");
    push(@implContent, "#include <wtf/RefPtr.h>\n\n");

    my $conditionalString = GenerateConditionalString($dataNode);
    push(@implContent, "\n#if ${conditionalString}\n\n") if $conditionalString;

    # START implementation
    %attributeNames = ();

    # - Attributes
    if ($numAttributes > 0) {
        foreach my $attribute (@{$dataNode->attributes}) {
            next if ShouldSkipTypeInImplementation($attribute);
            AddIncludesForType($attribute->signature->type);

            my $idlType = $codeGenerator->StripModule($attribute->signature->type);

            my $attributeName = $attribute->signature->name;
            my $attributeType = GetCType($attribute->signature->type, 0);
            my $attributeIsReadonly = ($attribute->type =~ /^readonly/);

            $attributeNames{$attributeName} = 1;

            # - GETTER
            my $getterSig = GenerateGetterPrototype($attribute, $interfaceName) . "\n";

            my $hasGetterException = @{$attribute->getterExceptions};
            my $getterContentInitial = "    WebCore::$interfaceName* coreObj = _to_webcore_" . lc($interfaceName) . "(self);\n";
            my $getterContentHead = "coreObj->" . $codeGenerator->GetterExpressionPrefix(\%implIncludes, $interfaceName, $attribute);
            my $getterContentTail = ")";

            # Special cases
            my @customGetterContent = ();
            if ($attribute->signature->extendedAttributes->{"ConvertToString"}) {
                $getterContentHead = "WTF::String::number(" . $getterContentHead;
                $getterContentTail .= ")";
            } elsif ($attribute->signature->type eq "SerializedScriptValue") {
                $getterContentHead = "$getterContentHead";
                $getterContentTail .= "->toString()";
            } elsif (IsWraperType($attributeType)) {

                if ($codeGenerator->IsStringType($attribute->signature->type)) {
                    $getterContentHead = "WTF::" . WraperType2CoreType($attributeType) . " result = " . $getterContentHead;
                    $getterContentTail .= ";\n    _to_webkit_" . lc(WraperType2CoreType($attributeType)) ."(&result, ret)";
                } else {
                    $getterContentHead = "RefPtr<WebCore::" . WraperType2CoreType($attributeType) . "> result = WTF::getPtr(" . $getterContentHead;
                    $getterContentTail .= ");\n    _to_webkit_" . lc(WraperType2CoreType($attributeType)) ."(result.get(), ret)";
                }
            }

            my $getterContent;
            if ($hasGetterException) {
                $getterContent = $getterContentHead . "ec" . $getterContentTail;
            } else {
                $getterContent = $getterContentHead . $getterContentTail;
            }

            my $attributeConditionalString = GenerateConditionalString($attribute->signature);
            push(@implContent, "/* #if ${attributeConditionalString}\n") if $attributeConditionalString;

            push(@implContent, $getterSig);
            push(@implContent, "{\n");
            push(@implContent, AddEarlyReturnStatement($attributeType));
            push(@implContent, @customGetterContent);
            push(@implContent, "$getterContentInitial");

            if ($hasGetterException) {
                if (!IsWraperType($attributeType) ) {
                        $getterContent = $attributeType . " result = " . $getterContent;
                }

                push(@implContent, "    $exceptionInit\n");
                push(@implContent, "    $getterContent;\n");
                push(@implContent, "    $exceptionRaiseOnError\n");

                if (!IsWraperType($attributeType)) {
                    push(@implContent, AddReturnStatement($attribute, "result"));
                }
            } else {
                if (IsWraperType($attributeType)) {
                    push(@implContent, "    " . $getterContent . ";\n");
                } else {
                    push(@implContent, AddReturnStatement($attribute, $getterContent));
                }
            }
            push(@implContent, "}\n\n");

            # - SETTER
            if (!$attributeIsReadonly and !$attribute->signature->extendedAttributes->{"Replaceable"}) {
                # Exception handling
                my $hasSetterException = @{$attribute->setterExceptions};

                my $coreSetterName = "set" . $codeGenerator->WK_ucfirst($attributeName);
                my $setterName = "set" . ucfirst($attributeName);
                my $argName = "new" . ucfirst($attributeName);
                my $arg = GetCTypeGetter($argName, $idlType);

                # The definition of ConvertToString is flipped for the setter
                if ($attribute->signature->extendedAttributes->{"ConvertToString"}) {
                    $arg = "WTF::String($arg).toInt()";
                }

                my $attributeType = GetCType($attribute->signature->type, 1);
                push(@implContent, "void ewk_webkitdom_" . lc($implClassName) . "_set_" . decamelize($attributeName) . "($className* self, $attributeType $argName)\n");
                push(@implContent, "{\n");
                push(@implContent, AddEarlyReturnStatement());
                push(@implContent,"    WebCore::$interfaceName* coreObj = _to_webcore_" . lc($interfaceName) . "(self);\n");

                push(@implContent, "    $exceptionInit\n") if $hasSetterException;
                my $ec = $hasSetterException ? ", ec" : "";
                my $setterExpressionPrefix = $codeGenerator->SetterExpressionPrefix(\%implIncludes, $interfaceName, $attribute);

                push(@implContent, "    coreObj->$setterExpressionPrefix$arg$ec);\n");
                push(@implContent, "    $exceptionRaiseOnError\n") if $hasSetterException;
                push(@implContent, "}\n\n");
            }

            push(@implContent, "#endif */\n") if $attributeConditionalString;
        }
    }

    # - Functions
    if ($numFunctions > 0) {
        foreach my $function (@{$dataNode->functions}) {
            # Treat PureInterface as Custom as well, since the WebCore versions will take a script context as well
            next if ShouldSkipTypeInImplementation($function) || $dataNode->extendedAttributes->{"PureInterface"};
            AddIncludesForType($function->signature->type);

            my $functionName = $function->signature->name;
            my $returnType = GetCType($function->signature->type, 0);
            my $hasParameters = @{$function->parameters};
            my $raisesExceptions = @{$function->raisesExceptions};

            my @parameterNames = ();
            my @needsAssert = ();
            my %needsCustom = ();

            my $parameterIndex = 0;

            my $functionSig = "";
            if (IsWraperType($returnType)) {
                $functionSig .= "void ewk_webkitdom_" . lc($implClassName) . "_" . decamelize($functionName) . "($className* self";
            } else {
                $functionSig .= "$returnType ewk_webkitdom_" . lc($implClassName) . "_" . decamelize($functionName) . "($className* self";
            }

            #my $functionSig = "$returnType $className\:\:$functionName(";
            foreach my $param (@{$function->parameters}) {
                my $paramName = $param->name;
                my $paramType = GetCType($param->type, 1);

                # make a new parameter name if the original conflicts with a property name
                $paramName = "in" . ucfirst($paramName) if $attributeNames{$paramName};

                AddIncludesForType($param->type);

                my $idlType = $codeGenerator->StripModule($param->type);
                my $implGetter = GetCTypeGetter($paramName, $idlType);

                push(@parameterNames, $implGetter);
                $needsCustom{"NodeToReturn"} = $paramName if $param->extendedAttributes->{"Return"};

                unless ($codeGenerator->IsPrimitiveType($idlType) or $codeGenerator->IsStringType($idlType)) {
                    push(@needsAssert, "    ASSERT($paramName);\n");
                }

                $functionSig .= ", ";# if $parameterIndex >= 1;
                $functionSig .= "$paramType $paramName";
                $parameterIndex++;
            }

            if (IsWraperType($returnType)) {
                $functionSig .= ", $returnType* ret";
            }

            $functionSig .= ")";

            my @functionContent = ();
            push(@parameterNames, "ec") if $raisesExceptions;
            my $content = "coreObj->" . $codeGenerator->WK_lcfirst($functionName) . "(" . join(", ", @parameterNames) . ")";

            if ($returnType eq "void") {
                # Special case 'void' return type.
                if ($raisesExceptions) {
                    push(@functionContent, "    $exceptionInit\n");
                    push(@functionContent, "    $content;\n");
                    push(@functionContent, "    $exceptionRaiseOnError\n");
                } else {
                    push(@functionContent, "    $content;\n");
                }
            } elsif (defined $needsCustom{"NodeToReturn"}) {
                # TODO: This is important to enable, once we care about custom code!

                # Special case the insertBefore, replaceChild, removeChild
                # and appendChild functions from DOMNode 
                my $toReturn = $needsCustom{"NodeToReturn"};
                if ($raisesExceptions) {
                    push(@functionContent, "    $exceptionInit\n");
                    push(@functionContent, "    if ($content)\n");
                    push(@functionContent, "        return $toReturn;\n");
                    push(@functionContent, "    $exceptionRaiseOnError\n");
                    push(@functionContent, "    return $className();\n");
                } else {
                    push(@functionContent, "    if ($content)\n");
                    push(@functionContent, "        return $toReturn;\n");
                    push(@functionContent, "    return NULL;\n");
                }
            } else {
                if (ConversionNeeded($function->signature->type)) {
                    $content = "WTF::getPtr($content)";
                }

                if (IsWraperType($returnType)) {
                    if ($codeGenerator->IsStringType($function->signature->type)) {
                        $content =  "WTF::" . WraperType2CoreType($returnType) . " result = " . $content;
                    } else {
                        $content = "RefPtr<WebCore::" . WraperType2CoreType($returnType) . "> result = " . $content;
                    }
                } else {
                    $content = "return " . $content;
                }

                if ($raisesExceptions) {
                        push(@functionContent, "// TODO: exceptions\n");
                        push(@functionContent, "    $exceptionInit\n");
                }

                push(@functionContent, "    $content;\n");
            }

            push(@implContent, "$functionSig\n");
            push(@implContent, "{\n");
            push(@implContent, AddEarlyReturnStatement($returnType));
            push(@implContent, "    WebCore::$interfaceName* coreObj = _to_webcore_" . lc($interfaceName) . "(self);\n");
            push(@implContent, @functionContent);

            if (IsWraperType($returnType)) {
                if ($codeGenerator->IsStringType($function->signature->type)) {
                    push(@implContent, "    _to_webkit_" . lc(WraperType2CoreType($returnType)) ."(&result, ret);\n\n");
                } else {
                    push(@implContent, "    _to_webkit_" . lc(WraperType2CoreType($returnType)) ."(result.get(), ret);\n\n");
                }
            }

            push(@implContent, "}\n\n");

            # Clear the hash
            %needsCustom = ();
        }
    }

    # END implementation
    push(@implContent, "\nvoid ewk_webkitdom_" . lc($implClassName) . "_deinit(const WebKitDOM_Object* objPtr)\n");
    push(@implContent, "{\n");
    push(@implContent, "    if( WEBKITDOM_ISNULL(objPtr) )\n");
    push(@implContent, "       return;\n");
    push(@implContent, "    ((WebCore::$implClassName*)(objPtr->p_coreObject))->deref();\n");
    push(@implContent, "    (((WebKitDOM_Object*)(objPtr))->p_coreObject) = 0;\n");
    push(@implContent, "}\n\n");

    push(@implContent, "void _copy_webkit_" . lc($implClassName). "($className* kitObjSrc, $className* ret)\n");
    push(@implContent, "{\n");
    push(@implContent, "    if (WEBKITDOM_COREOBJ(kitObjSrc) == WEBKITDOM_COREOBJ(ret))\n");
    push(@implContent, "        return;\n");
    push(@implContent, "    WebCore::$implClassName* tmpPtr = _to_webcore_" . lc($implClassName) . "(ret);\n");
    push(@implContent, "    if (tmpPtr)\n");
    push(@implContent, "        tmpPtr->deref();\n");
    push(@implContent, "    if (!WEBKITDOM_ISNULL(kitObjSrc))\n");
    push(@implContent, "        _to_webcore_". lc($implClassName) . "(kitObjSrc)->ref();\n");
    push(@implContent, "    ((WebKitDOM_Object*)ret)->p_coreObject = WEBKITDOM_COREOBJ(kitObjSrc);\n");
    push(@implContent, "}\n\n");

    # Generate internal interfaces
    push(@implContent, "WebCore::$implClassName* _to_webcore_" . lc($implClassName) . "(const $className* kitObj)\n");
    push(@implContent, "{\n");
    push(@implContent, "    return (WebCore::$implClassName*)WEBKITDOM_COREOBJ(kitObj);\n");
    push(@implContent, "}\n\n");

    push(@implContent, "$className* _to_webkit_" . lc($implClassName) . "(WebCore::$implClassName* coreObj, $className* ret)\n");
    push(@implContent, "{\n");
    push(@implContent, "    WebCore::$implClassName* tmpPtr = _to_webcore_" . lc($implClassName) . "(ret);\n");
    push(@implContent, "    if (tmpPtr && tmpPtr != coreObj)\n");
    push(@implContent, "        tmpPtr->deref();\n");
    push(@implContent, "    if (coreObj)\n");
    push(@implContent, "        coreObj->ref();\n");
    push(@implContent, "    ((WebKitDOM_Object*)ret)->p_coreObject = coreObj;\n");
    push(@implContent, "    return ret;\n");
    push(@implContent, "}\n\n");

    # - End the ifdef conditional if necessary
    push(@implContent, "\n#endif // ${conditionalString}\n") if $conditionalString;
}

# Internal helper
sub WriteData
{
    my $object = shift;
    my $name = shift;

    # Open files for writing...
    my $headerFileName = "$outputDir/" . $name . ".h";
    my $privateHeaderFileName = "$outputDir/" . $name . "_Private.h";
    my $implFileName = "$outputDir/" . $name . ".cpp";

    # Remove old files.
    unlink($headerFileName);
    unlink($privateHeaderFileName);
    unlink($implFileName);

    # Write public header.
    open(HEADER, ">$headerFileName") or die "Couldn't open file $headerFileName";

    print HEADER @headerContentHeader;
    print HEADER "\n";
    foreach my $class (sort keys(%headerForwardDeclarations)) {
        if ($class =~ /::/) {
            my $namespacePart = $class;
            $namespacePart =~ s/::.*//;

            my $classPart = $class;
            $classPart =~ s/${namespacePart}:://;

            print HEADER "namespace $namespacePart {\nclass $classPart;\n};\n\n";
        }
    }

    my $hasForwardDeclarations = keys(%headerForwardDeclarations);
    print HEADER "\n" if $hasForwardDeclarations;
    print HEADER @headerContent;
    close(HEADER);

    # Write private header.
    open(PRIVHEADER, ">$privateHeaderFileName") or die "Couldn't open file $privateHeaderFileName";

    print PRIVHEADER @privateHeaderContentHeader;
    print PRIVHEADER "\n";
    print PRIVHEADER @privateHeaderContent;
    close(PRIVHEADER);

    @privateHeaderContentHeader = ();
    @privateHeaderContent = ();

    # Write implementation file.
    open(IMPL, ">$implFileName") or die "Couldn't open file $implFileName";

    print IMPL @implContentHeader;

    foreach my $include (sort keys(%implIncludes)) {
        # "className.h" is already included right after config.h, silence check-webkit-style
        next if $include eq "$name.h";
        print IMPL "#include \"$include\"\n";
    }

    print IMPL @implContent;
    close(IMPL);

    @implContentHeader = ();
    @implContent = ();
    %implIncludes = ();
}

1;
